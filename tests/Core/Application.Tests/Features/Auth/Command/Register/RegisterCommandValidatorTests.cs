using Application.BuilderEntities;using Application.Common.Constants;namespace Application.Features.Auth.Command.Register;[TestFixture]public class RegisterCommandValidatorTests{    private RegisterCommandValidator _validator;    [SetUp]    public void Setup()    {        _validator = new RegisterCommandValidator();    }    [Theory]    [TestCaseSource(typeof(TestEmailConstants), nameof(TestEmailConstants.EmptyEmailCases))]    public void Email_WhenEmpty_ShouldHaveValidationError(string email)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithEmail(email)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldHaveValidationErrorFor(x => x.Email)            .WithErrorMessage(ValidationMessages.EmailRequired);    }    [Theory]    [TestCaseSource(typeof(TestEmailConstants), nameof(TestEmailConstants.InvalidEmailCases))]    public void Email_WhenFormatInvalid_ShouldHaveValidationError(string email)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithEmail(email)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldHaveValidationErrorFor(x => x.Email)            .WithErrorMessage(ValidationMessages.InvalidEmailFormat);    }    [Theory]    [TestCaseSource(typeof(TestEmailConstants), nameof(TestEmailConstants.ValidEmailCases))]    public void Email_WhenValid_ShouldNotHaveValidationError(string email)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithEmail(email)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldNotHaveValidationErrorFor(e => e.Email);    }    [Theory]    [TestCaseSource(typeof(TestPasswordConstants), nameof(TestPasswordConstants.EmptyPasswordCases))]    public void Password_WhenEmpty_ShouldHaveValidationError(string password)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithPassword(password)            .WithConfirmPassword(password)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldHaveValidationErrorFor(e => e.Password)            .WithErrorMessage(ValidationMessages.PasswordRequired);    }    [Theory]    [TestCaseSource(typeof(TestPasswordConstants), nameof(TestPasswordConstants.InvalidPasswordCases))]    public void Password_WhenTooShort_ShouldHaveValidationError(string password)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithPassword(password)            .WithConfirmPassword(password)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldHaveValidationErrorFor(e => e.Password)            .WithErrorMessage(ValidationMessages.PasswordTooShort);    }    [Theory]    [TestCaseSource(typeof(TestPasswordConstants), nameof(TestPasswordConstants.ValidPasswordCases))]    public void Password_WhenValid_ShouldNotHaveValidationError(string password)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithPassword(password)            .WithConfirmPassword(password)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldNotHaveValidationErrorFor(e => e.Password);    }    [Theory]    [TestCaseSource(typeof(TestPasswordConstants), nameof(TestPasswordConstants.ValidPasswordCases))]    public void ConfirmPassword_WhenDoesNotMatchPassword_ShouldHaveValidationError(string password)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithPassword(password)            .WithConfirmPassword(string.Join("", password.Reverse()))            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldHaveValidationErrorFor(e => e.ConfirmPassword)            .WithErrorMessage(ValidationMessages.ConfirmPasswordNotMatch);    }    [Theory]    [TestCaseSource(typeof(TestPasswordConstants), nameof(TestPasswordConstants.ValidPasswordCases))]    public void ConfirmPassword_WhenMatchPassword_ShouldNotHaveValidationError(string password)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithPassword(password)            .WithConfirmPassword(password)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldNotHaveValidationErrorFor(e => e.ConfirmPassword);    }    [Theory]    [TestCaseSource(typeof(TestUsernameConstants), nameof(TestUsernameConstants.EmptyUsernameCases))]    public void Username_WhenEmpty_ShouldHaveValidationError(string username)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithUserName(username)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldHaveValidationErrorFor(e => e.UserName)            .WithErrorMessage(ValidationMessages.UsernameRequired);    }    [Theory]    [TestCaseSource(typeof(TestUsernameConstants), nameof(TestUsernameConstants.TooBigUsernameCases))]    public void Username_WhenTooBig_ShouldHaveValidationError(string username)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithUserName(username)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldHaveValidationErrorFor(e => e.UserName)            .WithErrorMessage(ValidationMessages.UsernameLength);    }    [Theory]    [TestCaseSource(typeof(TestUsernameConstants), nameof(TestUsernameConstants.InValidCharactersUsernameCases))]    public void Username_WhenInValidCharacters_ShouldHaveValidationError(string username)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithUserName(username)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldHaveValidationErrorFor(e => e.UserName)            .WithErrorMessage(ValidationMessages.UsernameInvalidCharacters);    }    [Theory]    [TestCaseSource(typeof(TestUsernameConstants), nameof(TestUsernameConstants.ValidUsernameCases))]    public void Username_WhenValid_ShouldNotHaveValidationError(string username)    {        // Arrange        var command = new RegisterCommandBuilder()            .WithUserName(username)            .Build();        // Act        var result = _validator.TestValidate(command);        // Assert        result.ShouldNotHaveValidationErrorFor(e => e.UserName);    }}